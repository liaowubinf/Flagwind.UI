/*!
 * Flagwind.UI v1.0.0
 * Copyright 2014 Flagwind Inc. All rights reserved.
 * Licensed under the MIT License.
 * https://github.com/Flagwind/Flagwind.UI/blob/master/LICENSE
!*/

// @codekit-append "core.js";
// @codekit-append "animation.js";
// @codekit-append "dropdown.js";
// @codekit-append "alert.js";


/*!
 * Flagwind.UI [Core] v1.0.0
 * Copyright 2014 Flagwind Inc. All rights reserved.
 * Licensed under the MIT License.
 * https://github.com/Flagwind/Flagwind.UI/blob/master/LICENSE
!*/

+function($, window, document, undefined)
{
    "use strict";

    String.prototype.trim = function()
    {
         return this.replace(/^\s+/g,"").replace(/\s+$/g,"");
    };

    String.prototype.escape = function()
    {
        return this.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    };

    $.fw = $.fw || {};

    $.extend($.fw,
    {
        /**
         * @public 版本号。
         * @type {String}
         */
        version : "1.0.1",

        /**
         * @public 用于展示不同浏览器的特性。
         * @type {Object}
         */
        support :
        {
            /**
             * @public 是否支持触摸。
             * @type {Boolean}
             */
            hasTouch    :    ("ontouchstart" in document.documentElement)
        },

        /**
         * @public 键盘值。
         * @type {Object}
         */
        keyCodes:
        {
            BACKSPACE: 8,
            COMMA: 188,
            DELETE: 46,
            DOWN: 40,
            END: 35,
            ENTER: 13,
            ESCAPE: 27,
            HOME: 36,
            LEFT: 37,
            PAGE_DOWN: 34,
            PAGE_UP: 33,
            PERIOD: 190,
            RIGHT: 39,
            SPACE: 32,
            TAB: 9,
            UP: 38
        },

        /**
         * @public 空函数。
         * @type {Function}
         */
        empty : function(){},

        /**
         * @public 动态执行函数调用。
         * @param  {Object} instance   实例
         * @param  {String} name       函数名称
         * @param  {Object} parameters 函数参数
         * @param  {Object} scope      作用域实例
         * @return {Object}            函数执行后的返回值
         */
        invoke : function(instance, name, parameters, scope)
        {
            var names,
                maxDepth,
                found,
                response;

            if(typeof name === "string")
            {
                names = name.split(/[\. ]/);
                maxDepth = names.length - 1;

                $.each(names, function(depth, value)
                {
                    var camelCaseValue = (depth !== maxDepth) ? value + names[depth + 1].charAt(0).toUpperCase() + names[depth + 1].slice(1) : names[0];

                    if($.isPlainObject(instance[camelCaseValue]) && (depth !== maxDepth))
                    {
                        instance = instance[camelCaseValue];
                    }
                    else if(instance[camelCaseValue] !== undefined)
                    {
                        found = instance[camelCaseValue];

                        return false;
                    }
                    else if($.isPlainObject(instance[value]) && (depth !== maxDepth))
                    {
                        instance = instance[value];
                    }
                    else if(instance[value] !== undefined)
                    {
                        found = instance[value];

                        return false;
                    }
                    else
                    {
                        return false;
                    }
                });
            }

            if($.isFunction(found))
            {
                response = found.apply(scope || instance, parameters);
            }
            else if(found !== undefined)
            {
                response = found;
            }

            return response;
        },

        /**
         * @public 解析JSON参数。
         * @param  {String} parameters 参数
         * @return {Object}            解析后的JSON对象
         */
        parseOptions : function(parameters)
        {
            if($.isPlainObject(parameters))
            {
                return parameters;
            }

            var start = (parameters ? parameters.indexOf("{") : -1);
            var result = {};

            if(start != -1)
            {
                result = (new Function("", "var json = " + parameters.substr(start) +"; return JSON.parse(JSON.stringify(json));"))();
            }

            return result;
        }
    });

}(jQuery, window, document);

/*!
 * Flagwind.UI [Animation] v1.0.3
 * Copyright 2014 Flagwind Inc. All rights reserved.
 * Licensed under the MIT License.
 * https://github.com/Flagwind/Flagwind.UI/blob/master/LICENSE
!*/

+function($, window, document, undefined)
{
    "use strict";

    /*
     * @private @typedef 插件所需样式类名。
     * @type {Object}
     */
    var className =
    {
        animation: "animation",
        disabled: "disabled",
        animating: "animating",
        visible: "visible",
        hidden: "hidden",
        looping: "looping",
        inward: "in",
        outward: "out"
    };
   
    /**
     * @private @typedef 插件所需辅助实例。
     * @type {Object}
     * @property {String} animationEnd 动画完成后触发的事件名称
     * @property {String} animationName 动画规定名称
     */
    var support = (function()
    {
        var getAnimationInfo = function(animations)
        {
            var element = document.body || document.documentElement;

            for(var animation in animations)
            {
                if(element.style[animation] !== undefined)
                {
                    return animations[animation];
                }
            }

            return null;
        };

        var getAnimationName = function()
        {
            var animations = 
            {
                "animation": "animationName",
                "OAnimation": "oAnimationName",
                "MozAnimation": "mozAnimationName",
                "WebkitAnimation": "webkitAnimationName"
            };

            return getAnimationInfo(animations);
        };

        var getAnimationEnd = function()
        {
            var animations = 
            {
                "animation": "animationend",
                "OAnimation": "oAnimationEnd",
                "MozAnimation": "mozAnimationEnd",
                "WebkitAnimation": "webkitAnimationEnd"
            };

            return getAnimationInfo(animations);
        };

        var combineUnit = function(value, units)
        {
            if ((typeof value === "string") && (!value.match(/^[\-0-9\.]+$/)))
            {
                return value;
            }
            else
            {
                return "" + value + units;
            }
        }

        var parseDuration = function(duration)
        {
            if (typeof duration === "string" && (!duration.match(/^[\-0-9\.]+/)))
            {
                duration = $.fx.speeds[duration] || $.fx.speeds._default;
            }

            return combineUnit(duration, "ms");
        }

        return {
            animationEnd : getAnimationEnd(),
            animationName : getAnimationName(),
            parseDuration : parseDuration
        };
    })();
    
    /**
     * @private @class 初始化 Animation 类的新实例。
     * @param {Object} element 元素实例
     */
    var Animation = function(element)
    {
        this.$element = $(element);
    };

    /**
     * @public @static @property 受插件支持的动画名称表。
     * @type {Object}
     */
    Animation.animations = {};

    /**
     * Animation 类的原型实例。
     * @type {Object}
     */
    Animation.prototype =
    {
        /**
         * @private 重新指定原型的构造函数。
         * @type {function}
         */
        constructor : Animation,

        /**
         * @public 初始化函数。
         * @param  {Object} options 选项配置
         * @return {Void}
         */
        initialize : function(options)
        {
            var parameters = arguments,
                methodName = parameters[0],                             //截取第一个参数作为函数名
                methodInvoked = (typeof methodName === "string");       //根据函数名判断是否为函数调用

            // 合并选项
            this.options = $.extend(true, {}, $.fn.animation.settings, options);

            if(!methodInvoked)
            {
                // 执行动画
                this.animate();
            }
            else
            {
                // 执行函数调用
                $.fw.invoke(this, methodName, ([].slice.call(parameters, 1)));
            }
        },
        
        /**
         * @private 执行动画效果。
         * @return {Void}
         */
        animate : function()
        {
            // 检测是否支持 CSS 动画
            if(!this.isSupport())
            {
                this.onNoSupport();

                return;
            }

            // 检测是否需要加入队列
            if(this.isAnimating())
            {
                if(this.options.queue)
                {
                    if(this.options.allowRepeats || !this.hasDirection() || !this.isOccurring() || module.queuing !== false)
                    {
                        this.queue(this.options.animation);
                    }

                    return;
                }
                else if (!this.options.allowRepeats && this.isOccurring())
                {
                    return;
                }
                else
                {
                    this.complete();
                }
            }

            // 检测是否可支持动画
            if(this.canAnimate())
            {
                this.setAnimating(this.options.animation);
            }
            else
            {
                throw new Error("There is no css animation matching the one you specified.");
            }
        },

        /**
         * @private 将动画加入执行队列。
         * @param  {String} animation 动画名
         * @return {Void}
         */
        queue: function(animation)
        {
            var self = this;
            self.queuing = true;
            self.$element.one(support.animationEnd + ".queue" + this.options.eventSuffix, function(){ self.queuing = false; self.animate(); });
        },

        /**
         * @public 刷新动画效果。
         * @return {Void}
         */
        refresh : function()
        {
            delete this.displayType;
        },

        /**
         * @public 显示动画目标元素。
         * @return {Void}
         */
        show : function()
        {
            this.removeHidden();
            this.setVisible();
            this.setDisplay();
        },

        /**
         * @public 隐藏动画目标元素。
         * @return {Void}
         */
        hide : function()
        {
            if(this.isAnimating())
            {
                this.reset();
            }

            this.removeDisplay();
            this.removeVisible();
            this.setHidden();
        },

        /**
         * @public 切换动画目标元素。
         * @return {Void}
         */
        toggle : function()
        {
            if(this.isVisible())
            {
                this.hide();
            }
            else
            {
                this.show();
            }
        },

        /**
         * @public 停止当前正在执行的动画。
         * @return {Void}
         */
        stop : function()
        {
            this.$element.trigger(support.animationEnd);
        },

        /**
         * @public 停止当前正在执行的所有动画。
         * @return {Void}
         */
        stopAll : function()
        {
            this.removeQueueCallback();
            this.$element.trigger(support.animationEnd);
        },

        /**
         * @public 清除当前待执行的所有动画。
         * @return {Void}
         */
        clear : function()
        {
            this.removeQueueCallback();
        },

        /**
         * @public 启用动画目标元素。
         * @return {Void}
         */
        enable : function()
        {
            this.$element.removeClass(className.disabled);
        },

        /**
         * @public 禁用动画目标元素。
         * @return {Void}
         */
        disable : function()
        {
            this.$element.addClass(className.disabled);
        },

        /**
         * @public 重设动画目标元素。
         * @return {Void}
         */
        reset : function()
        {
            this.removeAnimationCallbacks();
            this.restoreConditions();
            this.removeAnimating();
        },

        /**
         * @private 动画执行完毕时调用。
         * @return {Void}
         */
        complete : function()
        {
            this.removeCompleteCallback();
            this.removeFailSafe();

            if(!this.isLooping())
            {
                if(this.isOutward())
                {
                    // 隐藏元素
                    this.restoreConditions();
                    this.hide();
                    this.onHide();
                }
                else if(this.isInward())
                {
                    // 显示元素
                    this.restoreConditions();
                    this.show();
                    this.onShow();
                }
                else
                {
                    this.restoreConditions();
                }

                this.removeAnimation();
                this.removeAnimating();
            }

            this.onComplete();
        },
        
        /**
         * @private 检测能否执行动画。
         * @param  {Boolean} forced 是否为强制的
         * @return {Boolean}        能否执行动画
         */
        canAnimate : function(forced)
        {
            var elementClass = this.$element.attr("class"),             // 元素样式
                tagName = this.$element.prop("tagName"),                // 元素标签
                animation = this.options.animation,                     // 动画效果名
                animationExists = Animation.animations[animation],
                $clone,
                currentAnimation,
                inAnimation,
                directionExists,
                displayType;

            if(animationExists === undefined || forced)
            {
                $clone = $("<" + tagName + " />").addClass(elementClass).insertAfter(this.$element);

                currentAnimation = $clone
                    .addClass(animation)
                    .removeClass(className.inward)
                    .removeClass(className.outward)
                    .addClass(className.animating)
                    .addClass(className.animation)
                    .css(support.animationName);

                inAnimation = $clone
                    .addClass(className.inward)
                    .css(support.animationName);

                displayType = $clone
                    .attr("class", elementClass)
                    .removeAttr("style")
                    .removeClass(className.hidden)
                    .removeClass(className.visible)
                    .show()
                    .css("display");

                this.$element.data("display", displayType);

                $clone.remove();

                directionExists = currentAnimation !== inAnimation;

                Animation.animations[animation] = directionExists;
            }

            return (animationExists !== undefined) ? animationExists : directionExists;
        },

        /**
         * @private 检测指定的动画名是否包含方向。
         * @param  {String}  animation 动画名
         * @return {Boolean}           检测结果
         */
        hasDirection : function(animation)
        {
            var result = false;

            animation = animation || this.options.animation;

            if(typeof animation === "string")
            {
                animation = animation.split(" ");

                $.each(animation, function(index, word)
                {
                    if(word === className.inward || word === className.outward)
                    {
                        result = true;
                    }
                });
            }

            return result;
        },

        /**
         * @private 开始执行动画。
         * @param {String} animation 动画名
         */
        setAnimating : function(animation)
        {
            var self = this;

            animation = animation || self.options.animation;

            if(!self.isAnimating())
            {
                self.saveConditions();
            }

            self.removeDirection();
            self.removeCompleteCallback();

            if(self.canAnimate() && !self.hasDirection())
            {
                self.setDirection();
            }

            self.removeHidden();
            self.setDisplay();

            self.$element.addClass(className.animating + " " + className.animation + " " + animation)
                   .addClass(animation)
                   .one(support.animationEnd + ".complete" + self.options.eventSuffix, function(){self.complete();});

            if(self.options.useFailSafe)
            {
                self.addFailSafe();
            }

            self.setDuration(self.options.duration);

            self.onStart();
        },

        /**
         * @private 设置显示方式。
         * @return {Void}
         */
        setDisplay : function()
        {
            var style = this.getStyle(),
                displayType = this.getDisplayType(),
                overrideStyle = style + "display: " + displayType + " !important;";

            this.$element.css("display", "");
            this.refresh();

            if(this.$element.css("display") !== displayType)
            {
                this.$element.attr("style", overrideStyle);
            }
        },

        /**
         * @private 设置为显示状态。
         * @return {Void}
         */
        setVisible : function()
        {
            this.$element.addClass(className.animation)
                         .addClass(className.visible);
        },

        /**
         * @private 设置为隐藏状态。
         * @return {Void}
         */
        setHidden : function()
        {
            if(!this.isHidden())
            {
                this.$element.addClass(className.animation)
                             .addClass(className.hidden);
            }

            if(this.$element.css("display") !== "none")
            {
                this.$element.css("display", "none");
            }
        },

        /**
         * @private 设置方向。
         * @return {Void}
         */
        setDirection : function()
        {
            if(this.$element.is(":visible") && !this.isHidden())
            {
                this.$element.removeClass(className.inward)
                             .addClass(className.outward);
            }
            else
            {
                this.$element.removeClass(className.outward)
                             .addClass(className.inward);
            }
        },

        /**
         * @private 设置动画时长。
         * @param {Number} duration 动画时长
         * @return {Void}
         */
        setDuration : function(duration)
        {
            duration = support.parseDuration(duration || this.options.duration);

            if(duration || duration === 0)
            {
                this.$element
                    .css
                    ({
                        "-webkit-animation-duration": duration,
                        "-moz-animation-duration": duration,
                        "-ms-animation-duration": duration,
                        "-o-animation-duration": duration,
                        "animation-duration": duration
                    });
            }
        },

        /**
         * @private 保存条件。
         * @return {Void}
         */
        saveConditions : function()
        {
            var options = this.options,
                clasName = this.$element.attr("class") || false,
                style = this.$element.attr("style") || "";

            this.$element.removeClass(options.animation);
            this.removeDirection();

            this.cache =
            {
                className   :    this.$element.attr("class"),
                style       :    this.getStyle()
            };
        },

        /**
         * @private 添加超时定时器。
         * @return {Void}
         */
        addFailSafe : function()
        {
            var self = this,
                duration = self.getDuration() + self.options.failSafeDelay;

            self.timer = setTimeout(function()
            {
                self.$element.trigger(support.animationEnd);

            }, duration);
        },

        /**
         * @private 移除正在动画中标示。
         * @return {Void}
         */
        removeAnimating : function()
        {
            this.$element.removeClass(className.animating);
        },

        /**
         * @private 移除动画效果。
         * @return {Void}
         */
        removeAnimation : function()
        {
            this.$element.css
            ({
                "-webkit-animation": "",
                "-moz-animation": "",
                "-ms-animation": "",
                "-o-animation": "",
                "animation": ""
            });
        },

        /**
         * @private 移除超时定时器。
         * @return {Void}
         */
        removeFailSafe : function()
        {
            if(this.timer)
            {
                clearTimeout(this.timer);
            }
        },

        /**
         * @private 移除显示方式。
         * @return {Void}
         */
        removeDisplay : function()
        {
            this.$element.css("display", "");
        },

        /**
         * @private 移除隐藏模式。
         * @return {Void}
         */
        removeHidden : function()
        {
            this.$element.removeClass(className.hidden);
        },

        /**
         * @private 移除显示模式。
         * @return {Void}
         */
        removeVisible : function()
        {
            this.$element.removeClass(className.visible);
        },

        /**
         * @private 移除循环。
         * @return {Void}
         */
        removeLooping : function()
        {
            if(this.isLooping())
            {
                this.reset();
                this.$element.removeClass(className.looping)
            }
        },

        /**
         * @private 移除过渡。
         * @return {Void}
         */
        removeTransition : function()
        {
            this.$element.removeClass(className.visible)
                         .removeClass(className.hidden);
        },

        /**
         * @private 移除方向。
         * @return {Void}
         */
        removeDirection : function()
        {
            this.$element.removeClass(className.inward)
                         .removeClass(className.outward);
        },

        /**
         * @private 移除队列回调。
         * @return {Void}
         */
        removeQueueCallback : function()
        {
            this.$element.off(".queue" + this.options.eventSuffix);
        },

        /**
         * @private 移除完成回调。
         * @return {Void}
         */
        removeCompleteCallback : function()
        {
            this.$element.off(".complete" + this.options.eventSuffix);
        },

        /**
         * @private 移除所有回调。
         * @return {Void}
         */
        removeAnimationCallbacks : function()
        {
            this.removeQueueCallback();
            this.removeCompleteCallback();
        },

        /**
         * @private 重置条件。
         * @return {Void}
         */
        restoreConditions : function()
        {
            var self = this;

            if(self.cache === undefined)
            {
                return;
            }

            if(self.cache.className)
            {
                self.$element.attr("class", self.cache.className);
            }
            else
            {
                self.$element.removeAttr("class");
            }

            if(self.cache.style)
            {
                self.$element.attr("style", self.cache.style);
            }
            else
            {
                self.$element.removeAttr("style");
            }
        },

        /**
         * @private 获取 Style 内容。
         * @return {String}
         */
        getStyle : function()
        {
            var self = this,
                style = self.$element.attr("style") || "";

            return style.replace(/display.*?;/, "");
        },

        /**
         * @private 获取显示方式。
         * @return {String}
         */
        getDisplayType : function()
        {
            var self = this;

            if(self.options.displayType !== null)
            {
                return self.options.displayType;
            }

            if(self.$element.data("display") === undefined)
            {
                self.canAnimate(true);
            }

            return self.$element.data("display");
        },

        /**
         * @private 获取动画时长。
         * @return {String}
         */
        getDuration : function(duration)
        {
            duration = duration || this.options.duration;

            if(!duration)
            {
                duration = this.$element.css("animation-duration") || 0;
            }

            return parseFloat(support.parseDuration(duration));
        },

        /**
         * @private 判断是否正在执行动画中。
         * @return {Boolean}
         */
        isAnimating : function()
        {
            return this.$element.hasClass(className.animating);
        },

        /**
         * @private 判断是否为 in 模式。
         * @return {Boolean}
         */
        isInward : function()
        {
            return this.$element.hasClass(className.inward);
        },

        /**
         * @private 判断是否为 out 模式。
         * @return {Boolean}
         */
        isOutward : function()
        {
            return this.$element.hasClass(className.outward);
        },

        /**
         * @private 判断是否为循环模式。
         * @return {Boolean}
         */
        isLooping : function()
        {
            return this.$element.hasClass(className.looping);
        },

        /**
         * @private 判断是否为事故模式。
         * @return {Boolean}
         */
        isOccurring : function(animation)
        {
            animation = animation || this.options.animation;
            
            animation = "." + animation.replace(" ", ".");

            return (this.$element.filter(animation).length > 0);
        },

        /**
         * @private 判断是否为显示模式。
         * @return {Boolean}
         */
        isVisible : function()
        {
            return this.$element.is(":visible");
        },

        /**
         * @private 判断是否为隐藏模式。
         * @return {Boolean}
         */
        isHidden : function()
        {
            return this.$element.css("visibility") === "hidden";
        },

        /**
         * @private 判断是否支持CSS动画。
         * @return {Boolean}
         */
        isSupport : function()
        {
            return(support.animationName !== null && support.animationEnd !== null);
        },

        /**
         * @private 当动画开始时调用。
         * @return {Void}
         */
        onStart : function()
        {
            // 触发元素事件
            this.$element.trigger("start" + this.options.eventSuffix);

            // 回调回调函数
            this.options.onStart.call(this);
        },

        /**
         * @private 当动画目标元素显示时调用。
         * @return {Void}
         */
        onShow : function()
        {
            // 触发元素事件
            this.$element.trigger("show" + this.options.eventSuffix);

            // 调用回调函数
            this.options.onShow.call(this);
        },

        /**
         * @private 当动画目标元素隐藏时调用。
         * @return {Void}
         */
        onHide : function()
        {
            // 触发元素事件
            this.$element.trigger("hide" + this.options.eventSuffix);

            // 调用回调函数
            this.options.onHide.call(this);
        },

        /**
         * @private 当动画完毕时调用。
         * @return {Void}
         */
        onComplete : function()
        {
            // 触发元素事件
            this.$element.trigger("complete" + this.options.eventSuffix);

            // 调用回调函数
            this.options.onComplete.call(this);
        },

        /**
         * @private 当CSS动画不支持时时调用。
         * @return {Void}
         */
        onNoSupport : function()
        {
            // 触发元素事件
            this.$element.trigger("nosupport" + this.options.eventSuffix);

            // 调用回调函数
            this.options.noSupport.call(this);
        }
    };

    $.fn.animation = function(options)
    {
        var parameters = arguments;

        return this.each(function()
        {
            var $element = $(this),
                instance   = $element.data($.fn.animation.settings.namespace);

            if(!instance)
            {
                $element.data($.fn.animation.settings.namespace, (instance = new Animation(this)));
            }

            instance.initialize.apply(instance, parameters);
        });
    };

    $.fn.animation.settings =
    {
        namespace        :    "fw.animation",
        eventSuffix      :    ".animation",
        displayType      :    null,
        useFailSafe      :    true,
        failSafeDelay    :    100,
        allowRepeats     :    false,
        queue            :    true,
        duration         :    "normal",
        onStart          :    $.fw.empty,
        onShow           :    $.fw.empty,
        onHide           :    $.fw.empty,
        onComplete       :    $.fw.empty,
        noSupport        :    $.fw.empty
    };

}(jQuery, window, document);


/*!
 * Flagwind.UI [Dropdown] v1.0.1
 * Copyright 2014 Flagwind Inc. All rights reserved.
 * Licensed under the MIT License.
 * https://github.com/Flagwind/Flagwind.UI/blob/master/LICENSE
!*/

+function($, window, document, undefined)
{
    "use strict";

    /**
     * @private @class 初始化 Dropdown 类的新实例。
     * @param {Object} element 元素实例
     */
    var Dropdown = function(element, options)
    {
        this.options = options;

        this.$element = $(element);
        this.$toggle = this.$element.children(options.selector.toggle);
        this.$content = this.$element.children(options.selector.content);
        this.$menu = this.$element.children(options.selector.menu);
        this.$items = this.$menu.find(options.selector.item);
        this.$text = this.$element.find(options.selector.text);
        this.$icon = this.$element.find(options.selector.icon);
        this.$search = this.$element.find(options.selector.search);
        this.$input = this.$element.find(options.selector.input);
        this.activated = false;

        this.setTabbable();
        this.saveDefaults();
        this.setSelected();

        this.bindMouseEvents();
        this.bindKeyboardEvents();
    };

    /**
     * Dropdown 类的原型实例。
     * @type {Object}
     */
    Dropdown.prototype =
    {
        /**
         * @private 重新指定原型的构造函数。
         * @type {function}
         */
        constructor : Dropdown,

        /**
         * @public 初始化函数。
         * @param  {Object} options 选项配置
         * @return {Void}
         */
        initialize : function(options)
        {
            var parameters = arguments,
                methodName = parameters[0],                             //截取第一个参数作为函数名
                methodInvoked = (typeof methodName === "string");       //根据函数名判断是否为函数调用

            // 执行函数调用
            if(methodInvoked)
            {
                $.fw.invoke(this, methodName, ([].slice.call(parameters, 1)));
            }
        },

        /**
         * @public 切换下拉内容的显示或隐藏。
         * @return {Void}
         */
        toggle : function()
        {
            if(this.isActive())
            {
                this.hide();
            }
            else
            {
                this.show();
            }
        },

        /**
         * 显示下拉内容。
         * @param  {Function} callback 回调函数
         * @return {Void}
         */
        show : function(callback)
        {
            var self = this;

            if(this.isSearchable() && this.isAllFiltered())
            {
                return;
            }

            if(!this.canShow() || this.isActive())
            {
                return;
            }

            // 添加焦点样式
            this.setFocus();

            // 隐藏其他菜单
            this.hideMenus();

            // 设置滚动条位置
            this.setScrollPosition(this.getActiveItem(), true);

            // 动画完毕回调函数
            var complete = function()
            {
                // 添加激活样式
                self.$element.addClass(self.options.className.active);

                // 绑定清除其他下拉组件事件
                if(self.canClick())
                {
                    self.bindIntent();
                }

                // 调用回调函数
                $.isFunction(callback) && callback.call(self);

                // 激发"show"相关事件
                self.onShow();
            };

            // 执行展开动画效果
            this.$content.animation
            ({
                animation   :    this.isUpward() ? "slide up in" : "slide down in",
                duration    :    this.options.duration,
                noSupport   :    complete,
                onComplete  :    complete
            });
        },

        /**
         * 隐藏下拉内容。
         * @param  {Function} callback 回调函数
         * @return {Void}
         */
        hide : function(callback)
        {
            var self = this;

            if(!this.isActive())
            {
                return;
            }

            // 取消焦点样式
            this.setBlur();

            // 取消绑定清除其他下拉组件事件
            if(self.canClick())
            {
                self.unbindIntent();
            }

            // 动画完毕回调函数
            var complete = function()
            {
                // 移除激活样式
                self.$element.removeClass(self.options.className.active);

                // 调用回调函数
                $.isFunction(callback) && callback.call(self);

                // 激发"hide"相关事件
                self.onHide();
            };

            // 执行隐藏动画效果
            this.$content.animation
            ({
                animation   :    this.isUpward() ? "slide up out" : "slide down out",
                duration    :    this.options.duration,
                noSupport   :    complete,
                onComplete  :    complete
            });
        },

        /**
         * 隐藏其他下拉菜单。
         * @return {Void}
         */
        hideMenus : function()
        {
            $(".dropdown").not(this.$element).has(this.options.selector.content + ":visible:not(." + this.options.className.animating + ")").dropdown("hide");
        },

        /**
         * 激活菜单项。
         * @param  {String} text       文本
         * @param  {String} value      值
         * @param  {Boolean} isBubbled 是否为冒泡的
         * @return {Void}
         */
        activate : function(text, value, isBubbled)
        {
            value = (value !== undefined) ? value : text;

            // 选中指定项
            this.setSelected(value);

            if(!isBubbled)
            {
                // 隐藏下拉菜单
                this.hide(function()
                {
                    this.removeFilteredItem();
                });
            }
            else
            {
                this.removeFilteredItem();
            }
        },

        /**
         * 搜索菜单项。
         * @return {Void}
         */
        search : function()
        {
            var keywords = this.$search.val();

            this.filter(keywords);

            if(this.canShow())
            {
                this.show();
            }
        },

        /**
         * 过滤搜索条件。
         * @param  {String} keywords 关键字
         * @return {Void}
         */
        filter : function(keywords)
        {
            var self = this,
                $results = $(),
                escapedKeywords = keywords.escape(),
                exactRegExp = new RegExp("^" + escapedKeywords, "igm"),
                fullTextRegExp = new RegExp(escapedKeywords, "ig"),
                allItemsFiltered;

            this.$items.each(function()
            {
                var $choice = $(this),
                    text = String(self.getChoiceText($choice, false)),
                    value = String(self.getChoiceValue($choice, text));

                if(text.match(exactRegExp) || value.match(exactRegExp))
                {
                    $results = $results.add($choice);
                }
            });

            this.removeFilteredItem();
            this.$items.not($results).addClass(this.options.className.filtered);

            this.removeSelectedItem();
            $results.eq(0).addClass(this.options.className.selected);

            if(this.isAllFiltered())
            {
                this.hide();

                this.onNoResults();
            }
        },

        /**
         * 选中搜索项。
         * @return {Void|
         */
        forceSelection : function()
        {
            var $currentlySelected = this.$items.not(this.options.className.filtered).filter("." + this.options.className.selected).eq(0),
                $activeItem = this.$items.filter("." + this.options.className.active).eq(0),
                $selectedItem = ($currentlySelected.length > 0) ? $currentlySelected : $activeItem,
                hasSelected = ($selectedItem.size() > 0);

            if(hasSelected)
            {
                this.onItemClick({target : $selectedItem.context}, $selectedItem);

                this.removeFilteredItem();
            }
            else
            {
                this.hide();
            }
        },

        /**
         * 设置选择选择元素为获得焦点状态。
         * @return {Void}
         */
        setFocus : function()
        {
            // 添加焦点样式
            this.$toggle.addClass(this.options.className.focus);
        },

        /**
         * 设置选择选择元素为失去焦点状态。
         * @return {Void}
         */
        setBlur : function()
        {
            // 移除焦点样式
            this.$toggle.removeClass(this.options.className.focus);
        },

        /**
         * 设置组件的 tabindex。
         * @return {Void}
         */
        setTabbable : function()
        {
            if(this.isSearchable())
            {
                // 获取触发元素的 tabindex
                var tabindex = this.isDisabled() ? "-1" : (this.$toggle.attr("tabindex") || 0);

                // 设置搜索框的 tabindex
                this.$search.val("").attr("tabindex", tabindex);

                // 删除触发元素的 tabindex
                this.$toggle.removeAttr("tabindex");
            }
            else
            {
                if(!this.$toggle.attr("tabindex"))
                {
                    this.$toggle.attr("tabindex", this.isDisabled() ? "-1" : "0");
                    this.$toggle.siblings("button").attr("tabindex", "-1");
                }
            }

            //this.$content.attr("tabindex", "-1");
        },

        /**
         * 根据指定的值选中菜单项。
         * @param {String} value 值
         * @return {Void}
         */
        setSelected : function(value)
        {
            var selectedText,
                selectedValue,
                $selectedItem = this.getItem(value);

            if($selectedItem && !$selectedItem.hasClass(this.options.className.active))
            {
                // 移除选中项样式
                this.removeActiveItem();
                this.removeSelectedItem();

                // 添加选中项选中样式
                $selectedItem.addClass(this.options.className.active)
                             .addClass(this.options.className.selected);

                selectedText = this.getChoiceText($selectedItem);
                selectedValue = this.getChoiceValue($selectedItem, selectedText);

                // 设置文本和值
                this.setText(selectedText);
                this.setValue(selectedValue);

                // 激发"change"相关事件
                this.onChange(selectedValue, selectedText, $selectedItem);
            }
        },

        /**
         * 设置组件文本。
         * @param {String} text 文本
         * @return {Void}
         */
        setText : function(text)
        {
            if(this.options.action !== "combobox")
            {
                // 移除文本样式
                this.$text.removeClass(this.options.className.filtered)
                          .removeClass(this.options.className.placeholder);

                // 设置文本内容
                if(this.options.preserveHTML)
                {
                    this.$text.html(text);
                }
                else
                {
                    this.$text.text(text);
                }
            }
        },

        /**
         * 设置组件值。
         * @param {String} value 值
         * @return {Void}
         */
        setValue : function(value)
        {
            if(this.$input.length > 0)
            {
                // 触发隐藏域的"change"事件
                this.$input.val(value).trigger("change");
            }
            else
            {
                this.$element.data(this.options.metadata.value, value);
            }
        },

        /**
         * 设置菜单滚动条的位置。
         * @param {Object} $item         菜单项
         * @param {Boolean} forceScroll 是否强制滚动
         * @return {Void}
         */
        setScrollPosition : function($item, forceScroll)
        {
            var edgeTolerance = 5,
                hasActive,
                offset,
                itemHeight,
                itemOffset,
                menuOffset,
                menuScroll,
                menuHeight,
                abovePage,
                belowPage;

            $item = $item || this.getActiveItem();

            hasActive = ($item && $item.length > 0);
            forceScroll = (forceScroll !== undefined) ? forceScroll : false;

            if($item && hasActive)
            {
                if(!this.$menu.hasClass(this.options.className.visible))
                {
                    this.$menu.addClass(this.options.className.loading);
                }

                menuHeight = this.$menu.height();
                itemHeight = $item.height();
                menuScroll = this.$menu.scrollTop();
                menuOffset = this.$menu.offset().top;
                itemOffset = $item.offset().top;
                offset     = menuScroll - menuOffset + itemOffset;
                belowPage  = menuScroll + menuHeight < (offset + edgeTolerance);
                abovePage  = ((offset - edgeTolerance) < menuScroll);

                if(abovePage || belowPage || forceScroll)
                {
                    this.$menu.scrollTop(offset)
                         .removeClass(this.options.className.loading);
                }
            }
        },

        /**
         * 设置过滤文本。
         * @return {Void}
         */
        setFiltered : function()
        {
            var searchValue = this.$search.val(),
                hasSearchValue = (typeof searchValue === "string" && searchValue.length > 0);

            if(hasSearchValue)
            {
                this.$text.addClass(this.options.className.filtered);
            }
            else
            {
                this.$text.removeClass(this.options.className.filtered);
            }
        },

        /**
         * 获取文本。
         * @return {String} 文本内容
         */
        getText : function()
        {
            return this.$text.text();
        },

        /**
         * 获取值。
         * @return {String} 值
         */
        getValue : function()
        {
            return String((this.$input.length > 0) ? this.$input.val() : this.$element.data(this.options.metadata.value));
        },

        /**
         * 根据指定的值获取菜单项。
         * @param  {String} value 值
         * @return {Object}       菜单项
         */
        getItem : function(value)
        {
            var self = this,
                $item = null;

            value = (value !== undefined) ? value : (this.getValue() !== undefined) ? this.getValue() : this.getText();

            if(value !== undefined)
            {
                this.$items.each(function()
                {
                    var $choice = $(this),
                        itemText = self.getChoiceText($choice),
                        itemValue = self.getChoiceValue($choice, itemText);

                    if(itemValue === value)
                    {
                        $item = $(this);

                        return true;
                    }
                    else if(!$item && itemText === value)
                    {
                        $item = $(this);

                        return true;
                    }
                });
            }

            return $item;
        },

        /**
         * 获取当前选择的菜单项。
         * @return {Object} 菜单项
         */
        getSelectedItem : function()
        {
            return this.$items.filter("."  + this.options.className.selected);
        },

        /**
         * 获取当前激活的菜单项。
         * @return {Object} 菜单项
         */
        getActiveItem : function()
        {
            return this.$items.filter("."  + this.options.className.active);
        },

        /**
         * 获取菜单项的文本。
         * @param  {Object} $item         菜单项
         * @param  {Boolean} preserveHTML 是否保存HTML
         * @return {String}               菜单项文本
         */
        getChoiceText : function($item, preserveHTML)
        {
            preserveHTML = (preserveHTML !== undefined) ? preserveHTML : this.options.preserveHTML;

            if($item !== undefined)
            {
                // 获取"data-text"属性中的内容
                if($item.data(this.options.metadata.text) !== undefined)
                {
                    return $item.data(this.options.metadata.text);
                }

                return preserveHTML ? $item.html().trim() : $item.text().trim();
            }
        },

        /**
         * 获取菜单项的值，如果值为空，则返回文本。
         * @param  {Object} $item 菜单项
         * @param  {String} text  菜单项文本
         * @return {String}       菜单项值
         */
        getChoiceValue : function($item, text)
        {
            // 解析菜单项文本
            text = text || this.getChoiceText($item);

            // 获取"data-value"属性中的内容
            if($item.data(this.options.metadata.value) !== undefined)
            {
                return String($item.data(this.options.metadata.value));
            }

            return text;
        },

        /**
         * 获取搜索框的事件名。
         * @return {[type]} [description]
         */
        getSearchEventName : function()
        {
            var input = this.$search[0];

            if(input)
            {
                return (input.oninput !== undefined) ? "input" : "keyup";
            }

            return null;
        },

        /**
         * 移除搜索框的文本。
         * @return {Void}
         */
        removeSearchText : function()
        {
            this.$search.val("");
        },

        /**
         * 移除选择的菜单项。
         * @return {Void}
         */
        removeSelectedItem : function()
        {
            this.$items.removeClass(this.options.className.selected);
        },

        /**
         * 移除激活的选择项。
         * @return {Void}
         */
        removeActiveItem : function()
        {
            this.$items.removeClass(this.options.className.active);
        },

        /**
         * 移除过滤的菜单项。
         * @return {Void}
         */
        removeFilteredItem : function()
        {
            this.$items.removeClass(this.options.className.filtered);
        },

        /**
         * 保存默认数据。
         * @return {Void}
         */
        saveDefaults : function()
        {
            this.saveDefaultText();
            this.savePlaceholderText();
            this.saveDefaultValue();
        },

        /**
         * 保存默认文本。
         * @return {Void}
         */
        saveDefaultText : function()
        {
            this.$element.data(this.options.metadata.defaultText, this.getText());
        },

        /**
         * 保存默认值。
         * @return {Void}
         */
        saveDefaultValue : function()
        {
            this.$element.data(this.options.metadata.defaultValue, this.getValue());
        },

        /**
         * 保存占位文本。
         * @return {Void}
         */
        savePlaceholderText : function()
        {
            if(this.$text.hasClass(this.options.className.placeholder))
            {
                this.$element.data(this.options.metadata.placeholderText, this.$text.text());
            }
        },

        /**
         * 检测当前下拉菜单是否为激活的。
         * @return {Boolean}
         */
        isActive : function()
        {
            return this.$element.hasClass(this.options.className.active);
        },

        /**
         * 检测当前菜单方向是否为向上。
         * @return {Boolean}
         */
        isUpward : function()
        {
            return this.$element.hasClass(this.options.className.upward);
        },

        /**
         * 检测当前下拉内容是否为隐藏状态。
         * @return {Boolean}
         */
        isHidden : function()
        {
            return this.$content.is(":hidden");
        },

        /**
         * 检测当前组件是否为支持下拉选择。
         * @return {Boolean}
         */
        isSelection : function()
        {
            return this.$element.hasClass(this.options.className.selection);
        },

        /**
         * 检测当前下拉组件是否支持查找。
         * @return {Boolean}
         */
        isSearchable : function()
        {
            return this.$search.length > 0;
        },

        /**
         * 检测菜单项是否全过滤。
         * @return {Boolean}
         */
        isAllFiltered : function()
        {
            return (this.$items.filter("." + this.options.className.filtered).length === this.$items.length);
        },

        /**
         * 检测组件是否为禁用状态。
         * @return {Boolean}
         */
        isDisabled : function()
        {
            return this.$toggle.hasClass(this.options.className.disabled) || this.$toggle.attr("disabled") === "disabled";
        },

        /**
         * 检测当前触发元素是否为可点击的。
         * @return {Boolean}
         */
        canClick : function()
        {
            return ($.fw.support.hasTouch || this.options.trigger === "click");
        },

        /**
         * 检测菜单项是否能被选中。
         * @param  {Object} $item 菜单项
         * @return {Boolean}
         */
        canSelect : function($item)
        {
            return !$item.hasClass(this.options.className.disabled) && !$item.hasClass(this.options.className.divider);
        },

        /**
         * 检测菜单是否为可呈现的。
         * @return {Boolean}
         */
        canShow : function()
        {
            return !this.$toggle.hasClass(this.options.className.disabled) && this.$toggle.attr("disabled") !== "disabled";
        },

        /**
         * 绑定清除其他下拉组件事件
         * @return {Void}
         */
        bindIntent : function()
        {
            var self = this;

            if($.fw.support.hasTouch)
            {
                $(document).on("touchstart" + this.options.eventSuffix, $.proxy(self.onTouch, this))
                           .on("touchmove" + this.options.eventSuffix, $.proxy(self.onTouch, this));
            }

            $(document).on("click" + this.options.eventSuffix, function(e)
            {
                if($(e.target).closest(self.$element).length === 0)
                {
                    self.hide();
                }
            });
        },

        /**
         * 解除绑定清除其他下拉组件事件。
         * @return {Void}
         */
        unbindIntent : function()
        {
            if($.fw.support.hasTouch)
            {
                $(document).off("touchstart" + this.options.eventSuffix)
                           .off("touchmove" + this.options.eventSuffix);

            }

            $(document).off("click" + this.options.eventSuffix);
        },

        /**
         * 绑定鼠标相关事件。
         * @return {Void}
         */
        bindMouseEvents : function()
        {
            var self = this,
                trigger = this.options.trigger;

            // 绑定下拉组件鼠标事件
            this.$element.on("mousedown" + this.options.eventSuffix, $.proxy(this.onMousedown, this))
                         .on("mouseup" + this.options.eventSuffix, $.proxy(this.onMouseup, this));

            if(this.isSelection())
            {
                this.$icon.on("click" + this.options.eventSuffix, $.proxy(function(e)
                {
                    e.preventDefault();
                    e.stopPropagation();

                    self.toggle();

                }, this));
            }

            if(this.isSearchable())
            {
                // 绑定搜索文本框焦点事件
                this.$search.on("focus" + this.options.eventSuffix, $.proxy(this.onFocus, this))
                            .on("blur" + this.options.eventSuffix, $.proxy(this.onBlur, this))
                            .on("click" + this.options.eventSuffix, $.proxy(this.onSearchClick, this));

                this.$element.on("click" + this.options.eventSuffix, this.options.selector.text, $.proxy(this.onSearchClick, this));
            }
            else
            {
                // 点击触发处理
                if(trigger === "click")
                {
                    this.$toggle.on("click" + this.options.eventSuffix, function(e)
                    {
                        e.preventDefault();

                        self.toggle();
                    });
                }
                // 移入触发处理
                else if(trigger === "hover")
                {
                    this.$element.on("mouseenter" + this.options.eventSuffix, function(e)
                    {
                        e.preventDefault();

                        clearTimeout(self.timer);

                        self.timer = setTimeout($.proxy(self.show, self), self.options.delay.show);
                    });

                    this.$element.on("mouseleave" + this.options.eventSuffix, function(e)
                    {
                        e.preventDefault();

                        clearTimeout(self.timer);

                        self.timer = setTimeout($.proxy(self.hide, self), self.options.delay.hide);
                    });
                }

                // 绑定触发元素焦点事件
                this.$toggle.on("focus" + this.options.eventSuffix, $.proxy(this.onFocus, this))
                             .on("blur" + this.options.eventSuffix, $.proxy(this.onBlur, this));
            }

            // 绑定菜单项点击事件
            this.$menu.on("click" + this.options.eventSuffix, this.options.selector.item, $.proxy(this.onItemClick, this));
        },

        /**
         * 绑定键盘相关事件。
         * @return {Void}
         */
        bindKeyboardEvents : function()
        {
            // 绑定键盘(上/下/回车)事件。
            this.$element.on("keydown" + this.options.eventSuffix, $.proxy(this.onKeydown, this));

            //绑定搜索事件。
            if(this.isSearchable())
            {
                this.$element.on(this.getSearchEventName(), this.options.selector.search, $.proxy(this.onSearch, this));
            }
        },

        /**
         * 当触摸屏幕时调用。
         * @param  {Object} e 事件对象
         * @return {Void}
         */
        onTouch : function(e)
        {
            var self = this;

            if($(e.target).closest(self.$element).length === 0)
            {
                if(e.type == "touchstart")
                {
                    self.timer = setTimeout(function()
                    {
                        if(self.isSearchable())
                        {
                            self.hide();
                        }
                        else
                        {
                            self.$toggle.blur();
                        }

                    }, this.options.delay.touch);
                }
                else if(e.type == "touchmove")
                {
                    clearTimeout(self.timer);
                }
            }

            e.stopPropagation();
        },

        /**
         * 当菜单激活时调用。
         * @return {Void}
         */
        onMenuActivate : function()
        {
            this.itemActivated = true;
        },

        /**
         * 当菜单取消激活时调用。
         * @return {Void}
         */
        onMenuDeactivate : function()
        {
            this.itemActivated = false;
        },

        /**
         * 当菜单项点击时调用。
         * @param  {Object} e 事件参数
         * @return {Void}
         */
        onItemClick : function(e, $selectedItem)
        {
            var $choice = $selectedItem || $(e.currentTarget),
                isBubbled = $(e.target).is("button"),
                text = this.getChoiceText($choice),
                value = this.getChoiceValue($choice, text);

            // 检测是否能被选中
            if(!this.canSelect($choice))
            {
                return;
            }

            this.removeSearchText();

            // 选择处理动作
            if($.isFunction(this[this.options.action]))
            {
                this[this.options.action](text, value, isBubbled);
            }
            else if($.isFunction(this.options.action))
            {
                this.options.action.call(this, text, value, isBubbled);
            }
        },

        /**
         * 当键盘按下时调用。
         * @param  {Object} e 事件参数
         * @return {Void}
         */
        onKeydown : function(e)
        {
            var $nextItem,
                pressedKey = e.which,
                $currentlySelected = this.$items.not(this.options.className.filtered).filter("." + this.options.className.selected).eq(0),
                $activeItem = this.$menu.children("." + this.options.className.active).eq(0),
                $selectedItem = ($currentlySelected.length > 0) ? $currentlySelected : $activeItem,
                $visibleItems = ($selectedItem.length > 0) ? $selectedItem.siblings(":not(." + this.options.className.filtered + ")").andSelf() : this.$menu.children(":not(." + this.options.className.filtered + ")"),
                hasSelectedItem  = ($selectedItem.length > 0);

            if(this.isActive())
            {
                // 向上键
                if(pressedKey == $.fw.keyCodes.UP)
                {
                    $nextItem = hasSelectedItem ? $selectedItem.prevAll(this.options.selector.item + ":not(." + this.options.className.filtered + ")").eq(0) : this.$items.eq(0);

                    if ($visibleItems.index($nextItem) < 0)
                    {
                        return;
                    }
                    else
                    {
                        $selectedItem.removeClass(this.options.className.selected);
                        $nextItem.addClass(this.options.className.selected);

                        this.setScrollPosition($nextItem);
                    }

                    e.preventDefault();
                }
                // 向下键
                else if(pressedKey == $.fw.keyCodes.DOWN)
                {
                    $nextItem = hasSelectedItem ? $selectedItem.nextAll(this.options.selector.item + ":not(." + this.options.className.filtered + ")").eq(0) : this.$items.eq(0);

                    if($nextItem.length === 0)
                    {
                        return;
                    }
                    else
                    {
                        this.$items.removeClass(this.options.className.selected);
                        $nextItem.addClass(this.options.className.selected);

                        this.setScrollPosition($nextItem);
                    }
                }
                // 回车键
                else if(pressedKey == $.fw.keyCodes.ENTER)
                {
                    this.onItemClick(e, $selectedItem);

                    if(this.isSearchable())
                    {
                        e.preventDefault();
                    }
                }
                // ESC 键
                else if(pressedKey == $.fw.keyCodes.ESCAPE)
                {
                    this.hide();
                }
            }
            else
            {
                // 内容朝上时按上键显示内容
                if(this.isUpward() && (pressedKey == $.fw.keyCodes.UP || pressedKey == $.fw.keyCodes.DOWN))
                {
                    this.show();
                }

                // 内容朝下时按下键显示内容
                if(!this.isUpward() && pressedKey == $.fw.keyCodes.DOWN)
                {
                    this.show();
                }
            }
        },

        /**
         * 当触发搜索时调用。
         * @param  {Object} e 事件参数
         * @return {Void}
         */
        onSearch : function(e)
        {
            var pressedKey = e.which;

            if(pressedKey == $.fw.keyCodes.UP || pressedKey == $.fw.keyCodes.DOWN || pressedKey == $.fw.keyCodes.ENTER)
            {
                return;
            }

            // 设置过滤样式。
            this.setFiltered();

            clearTimeout(this.timer);

            this.timer = setTimeout($.proxy(this.search, this), this.options.delay.search);
        },

        /**
         * 当搜索框点击时调用。
         * @param  {Object} e 事件参数
         * @return {Void}
         */
        onSearchClick : function(e)
        {
            this.$search.focus();
        },

        /**
         * 当下拉组件鼠标按下时调用。
         * @return {Void}
         */
        onMousedown : function()
        {
            this.activated = true;
        },

        /**
         * 当下拉组件鼠标弹起时调用。
         * @return {Void}
         */
        onMouseup : function()
        {
            this.activated = false;
        },

        /**
         * 当触发元素获得焦点时调用。
         * @return {Void}
         */
        onFocus : function()
        {
            if(!this.activated && this.isHidden())
            {
                this.show();
            }
        },

        /**
         * 当触发元素失去焦点时调用。
         * @return {Void}
         */
        onBlur : function(e)
        {
            var pageLostFocus = (document.activeElement === e.target);

            if(!this.activated && !pageLostFocus)
            {
                if(this.isSearchable() && this.options.forceSelection)
                {
                    this.forceSelection();
                }
                else
                {
                    this.hide();
                }
            }
        },

        /**
         * 当下拉菜单发生改变时调用。
         * @param  {String} value 值
         * @param  {String} text  文本
         * @param  {Object} $item 菜单项
         * @return {Void}
         */
        onChange : function(value, text, $item)
        {
            // 触发元素事件
            this.$element.trigger("change" + this.options.eventSuffix, [value, text, $item]);

            // 调用回调函数
            this.options.onChange.call(this, value, text, $item);
        },

        /**
         * 当下拉菜单显示时调用。
         * @return {Void}
         */
        onShow : function()
        {
            // 触发元素事件
            this.$element.trigger("show" + this.options.eventSuffix);

            // 调用回调函数
            this.options.onShow.call(this);
        },

        /**
         * 当下拉菜单隐藏时调用。
         * @return {Void}
         */
        onHide : function()
        {
            // 触发元素事件
            this.$element.trigger("hide" + this.options.eventSuffix);

            // 调用回调函数
            this.options.onHide.call(this);
        },

        /**
         * 当没有搜索结果时调用。
         * @return {Void}
         */
        onNoResults : function()
        {
            // 触发元素事件
            this.$element.trigger("noresults" + this.options.eventSuffix);

            // 调用回调函数
            this.options.onNoResults.call(this);
        }
    };

    $.fn.dropdown = function(options)
    {
        var parameters = arguments;

        return this.each(function()
        {
            var plainObject,
                $element = $(this),
                instance   = $element.data($.fn.dropdown.settings.namespace);

            if(!instance)
            {
                plainObject = $.extend(true, {}, $.fn.dropdown.settings, $.fw.parseOptions($element.data("dropdown")), options);

                $element.data($.fn.dropdown.settings.namespace, (instance = new Dropdown(this, plainObject)));
            }

            instance.initialize.apply(instance, parameters);
        });
    };

    $.fn.dropdown.settings =
    {
        namespace       :    "fw.dropdown",
        eventSuffix     :    ".dropdown",
        trigger         :    "click",                               // 触发类型：click(点击) | hover(移入)
        action          :    "activate",                            // 点击动作：activate(激活)
        duration        :    250,                                   // 动画时长
        preserveHTML    :    false,                                 // 是否支持HTML
        forceSelection  :    true,
        className       :
        {
            focus       :    "focus",
            active      :    "active",
            animating   :    "animating",
            selected    :    "selected",
            disabled    :    "disabled",
            filtered    :    "filtered",
            placeholder :    "default",
            loading     :    "loading",
            visible     :    "visible",
            divider     :    "divider",
            upward      :    "dropdown-up",
            selection   :    "dropdown-selection"
        },
        selector        :
        {
            toggle      :    ".dropdown-toggle",
            content     :    ".dropdown-content",
            text        :    ".text:not(.icon)",
            icon        :    ".dropdown-toggle > .icon",
            search      :    ".search",
            input       :    "> input[type='hidden'], > select",
            menu        :    "ul.dropdown-content",
            item        :    "li:not(.divider):not(.disabled)"
        },
        metadata        :
        {
            defaultText         :   "defaultText",
            defaultValue        :   "defaultValue",
            placeholderText     :   "placeholderText",
            text                :   "text",
            value               :   "value"
        },
        delay           :
        {
            show        :     150,
            hide        :     250,
            search      :     50,
            touch       :     50
        },
        onShow          :    $.fw.empty,
        onHide          :    $.fw.empty,
        onChange        :    $.fw.empty,
        onNoResults     :    $.fw.empty
    };

}(jQuery, window, document);

$(function()
{
    $(".dropdown").dropdown();
});

/*!
 * Flagwind.UI [Alert] v1.0.0
 * Copyright 2014 Flagwind Inc. All rights reserved.
 * Licensed under the MIT License.
 * https://github.com/Flagwind/Flagwind.UI/blob/master/LICENSE
!*/

+function($, window, document, undefined)
{
    'use strict';

    /**
     * [Alert 构造函数]
     * @param {[type]} element [DOM元素]
     * @param {[type]} options [参数]
     */
    var Alert = function(element, options)
    {
        this.options = options;
        this.$element = $(element);
        this.$close = this.$element.find(this.options.selector.close);

        this.bindEvents();
    };

    /**
     * [prototype 原型]
     * @type {[type]}
     */
    Alert.prototype =
    {
        constructor: Alert,

        initialize: function(options)
        {
            var parameters = arguments,
                methodName = parameters[0],
                methodInvoked = (typeof methodName === "string");

            if(methodInvoked)
            {
                $.fw.invoke(this, methodName, ([].slice.call(parameters, 1)));
            }
        },

        close: function(callback)
        {
            var self = this;

            // 删除元素
            var complete = function()
            {
                self.$element.remove();
                self.onClose();
            };

            // 动画完毕执行回调函数
            this.$element.animation
            ({
                animation: 'fade out',
                duration: this.options.duration,
                queue: false,
                noSupport: complete,
                onComplete: complete
            });
        },

        onClose: function()
        {
            // 触发元素事件
            this.$element.trigger("close" + this.options.eventSuffix);

            // 调用回调函数
            this.options.onClose.call(this);
        },

        bindEvents: function()
        {
            this.$close.on('click' + this.options.eventSuffix, $.proxy(this.close, this));
        }
    };

    /**
     * [alert 扩展到jQuery]
     * @param  {[type]} options [description]
     * @return {[type]}         [description]
     */
    $.fn.alert = function(options)
    {
        var parameters = arguments;

        return this.each(function()
        {
            var plainObject,
                $element = $(this),

                instance   = $element.data($.fn.alert.settings.namespace);

            if(!instance)
            {
                plainObject = $.extend(true, {}, $.fn.alert.settings, $.fw.parseOptions($element.data("alert")), options);
                instance = new Alert(this, plainObject);

                $element.data($.fn.alert.settings.namespace, instance);
            }

            instance.initialize.apply(instance, parameters);
        });
    };

    /**
     * [settings 默认设置]
     * @type {[type]}
     */
    $.fn.alert.settings =
    {
        namespace: 'fw.alert',
        eventSuffix: '.alert',
        duration: 1000,
        selector:
        {
            close: '.close'
        },
        onClose : $.fw.empty
    };
}(jQuery, window, document);

// 调用插件
// $('.alert').alert(
// {
//     onClose: function()
//     {
//         console.log('已关闭');
//     }
// });

